(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{1136:function(v,e,_){"use strict";_.r(e);var t=_(29),a=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[v._v("#")]),v._v(" Vue")]),v._v(" "),_("h2",{attrs:{id:"_1-vue数据劫持-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue数据劫持-中级"}},[v._v("#")]),v._v(" 1. vue数据劫持（中级）")]),v._v(" "),_("p",[_("strong",[v._v("数据劫持：")]),v._v(" vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过"),_("code",[v._v("Object.defineProperty()")]),v._v("来劫持各个属性的"),_("code",[v._v("setter")]),v._v(","),_("code",[v._v("getter")]),v._v(",在数据变动时发布消息给订阅者，触发相应的监听回调。")]),v._v(" "),_("h2",{attrs:{id:"_2-阐述一下你所理解的mvvm响应式原理-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-阐述一下你所理解的mvvm响应式原理-中级"}},[v._v("#")]),v._v(" 2. 阐述一下你所理解的MVVM响应式原理（中级）")]),v._v(" "),_("p",[v._v("vue 是采用数据劫持配合发布者-订阅者的模式的方式，通过"),_("code",[v._v("Object.defineProperty()")]),v._v("来劫持各个属性的 getter 和 setter，在数据变动时，发布消息给依赖收集器( dep 中的subs)，去通知(notify)观察者，做出对应的回调函数，去更新视图。")]),v._v(" "),_("p",[v._v("MVVM 作为绑定的入口，整合 Observer,Compile 和 Watcher 三者，通过 Observer 来监听 model 数据变化，通过 Compile 来解析编译模板指令，最终利用Watcher 搭起 Observer，Compile 之间的通信桥路，达到数据变化=>视图更新；视图交互变化=>数据 model 变更的双向绑定效果。")]),v._v(" "),_("h2",{attrs:{id:"_3-说说vue的生命周期-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-说说vue的生命周期-中级"}},[v._v("#")]),v._v(" 3. 说说vue的生命周期（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("beforeCreate")]),v._v(" "),_("ul",[_("li",[v._v("创建之前，此时还没有 data 和 Method。")])])]),v._v(" "),_("li",[_("p",[v._v("Created")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("创建完成，此时 data 和 Method 可以使用了。")])]),v._v(" "),_("li",[_("p",[v._v("在 Created 之后 beforeMount 之前如果没有el选项的话那么此时生命周期结束，停止编译，如果有则继续。")])])])]),v._v(" "),_("li",[_("p",[v._v("beforeMount")]),v._v(" "),_("ul",[_("li",[v._v("在渲染之前。")])])]),v._v(" "),_("li",[_("p",[v._v("mounted")]),v._v(" "),_("ul",[_("li",[v._v("页面已经渲染完成，并且"),_("code",[v._v("vm")]),v._v("实例中已经添加完"),_("code",[v._v("$el")]),v._v("了，已经替换掉那些 DOM 元素了(双括号中的变量)，这个时候可以操作 DOM 了(但是是获取不了元素的高度等属性的，如果想要获取，需要使用"),_("code",[v._v("nextTick()")]),v._v(")。")])])]),v._v(" "),_("li",[_("p",[v._v("beforeUpdate")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("data")]),v._v("改变后，对应的组件重新渲染之前。")])])]),v._v(" "),_("li",[_("p",[v._v("updated")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("data")]),v._v("改变后，对应的组件重新渲染完成。")])])]),v._v(" "),_("li",[_("p",[v._v("beforeDestory")]),v._v(" "),_("ul",[_("li",[v._v("在实例销毁之前，此时实例仍然可以使用。")])])]),v._v(" "),_("li",[_("p",[v._v("destoryed")]),v._v(" "),_("ul",[_("li",[v._v("实例销毁后。")])])])]),v._v(" "),_("h2",{attrs:{id:"_4-vue-中父子组件的生命周期-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-中父子组件的生命周期-中级"}},[v._v("#")]),v._v(" 4. vue 中父子组件的生命周期（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("父子组件的生命周期是一个嵌套的过程。")])]),v._v(" "),_("li",[_("p",[v._v("渲染的过程。")]),v._v(" "),_("ul",[_("li",[v._v("父"),_("code",[v._v("beforeCreate")]),v._v("->父"),_("code",[v._v("created")]),v._v("->父"),_("code",[v._v("beforeMount")]),v._v("->子"),_("code",[v._v("beforeCreate")]),v._v("->子"),_("code",[v._v("created")]),v._v("->子"),_("code",[v._v("beforeMount")]),v._v("->子"),_("code",[v._v("mounted")]),v._v("->父"),_("code",[v._v("mounted")])])])]),v._v(" "),_("li",[_("p",[v._v("子组件更新过程。")]),v._v(" "),_("ul",[_("li",[v._v("父"),_("code",[v._v("beforeUpdate")]),v._v("->子"),_("code",[v._v("beforeUpdate")]),v._v("->子"),_("code",[v._v("updated")]),v._v("->父"),_("code",[v._v("updated")])])])]),v._v(" "),_("li",[_("p",[v._v("父组件更新过程。")]),v._v(" "),_("ul",[_("li",[v._v("父"),_("code",[v._v("beforeUpdate")]),v._v("->父"),_("code",[v._v("updated")])])])]),v._v(" "),_("li",[_("p",[v._v("销毁过程。")]),v._v(" "),_("ul",[_("li",[v._v("父"),_("code",[v._v("beforeDestroy")]),v._v("->子"),_("code",[v._v("beforeDestroy")]),v._v("->子"),_("code",[v._v("destroyed")]),v._v("->父"),_("code",[v._v("destroyed")])])])])]),v._v(" "),_("h2",{attrs:{id:"_5-vue-中的nexttick-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-中的nexttick-中级"}},[v._v("#")]),v._v(" 5. Vue 中的"),_("code",[v._v("nextTick")]),v._v("（中级）")]),v._v(" "),_("ul",[_("li",[v._v("nextTick\n"),_("ul",[_("li",[v._v("解释。\n"),_("ul",[_("li",[_("code",[v._v("nextTick")]),v._v("：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。")])])]),v._v(" "),_("li",[v._v("应用。\n"),_("ul",[_("li",[v._v("想要在 Vue 生命周期函数中的"),_("code",[v._v("created()")]),v._v("操作 DOM 可以使用"),_("code",[v._v("Vue.nextTick()")]),v._v("回调函数。")]),v._v(" "),_("li",[v._v("在数据改变后要执行的操作，而这个操作需要等数据改变后而改变 DOM 结构的时候才进行操作，需要用到"),_("code",[v._v("nextTick")]),v._v("。")])])])])])]),v._v(" "),_("h2",{attrs:{id:"_6-computed-和-watch-的区别-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-computed-和-watch-的区别-中级"}},[v._v("#")]),v._v(" 6. computed 和 watch 的区别（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("computed")]),v._v(" "),_("ul",[_("li",[v._v("计算属性，依赖其他属性，当其他属性改变的时候下一次获取computed值时也会改变，"),_("code",[v._v("computed")]),v._v("的值会有缓存。")])])]),v._v(" "),_("li",[_("p",[v._v("watch")]),v._v(" "),_("ul",[_("li",[v._v("类似于数据改变后的回调。")]),v._v(" "),_("li",[v._v("如果想深度监听的话，后面加一个"),_("code",[v._v("deep:true")]),v._v("。")]),v._v(" "),_("li",[v._v("如果想监听完立马运行的话，后面加一个"),_("code",[v._v("immediate:true")]),v._v("。")])])])]),v._v(" "),_("h2",{attrs:{id:"_7-vue-优化方式-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-优化方式-中级"}},[v._v("#")]),v._v(" 7. Vue 优化方式（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("v-if 和v-show。")])]),v._v(" "),_("li",[_("p",[v._v("使用"),_("code",[v._v("Object.freeze()")]),v._v("方式冻结data中的属性，从而阻止数据劫持。")])]),v._v(" "),_("li",[_("p",[v._v("组件销毁的时候会断开所有与实例联系，但是除了"),_("code",[v._v("addEventListener")]),v._v("，所以当一个组件销毁的时候需要手动去"),_("code",[v._v("removeEventListener")])])]),v._v(" "),_("li",[_("p",[v._v("图片懒加载。")])]),v._v(" "),_("li",[_("p",[v._v("路由懒加载。")])]),v._v(" "),_("li",[_("p",[v._v("为减少重新渲染和创建 dom 节点的时间，采用虚拟 dom。")])])]),v._v(" "),_("h2",{attrs:{id:"_8-vue-router-的模式-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-router-的模式-中级"}},[v._v("#")]),v._v(" 8. Vue-router 的模式（中级）")]),v._v(" "),_("ul",[_("li",[v._v("hash模式。\n"),_("ul",[_("li",[v._v("利用 onhashchange 事件实现前端路由，利用 url 中的 hash 来模拟一个 hash，以保证 url 改变时，页面不会重新加载。")])])]),v._v(" "),_("li",[v._v("history模式。\n"),_("ul",[_("li",[v._v("利用 pushstate 和 replacestate 来将 url 替换但不刷新，但是有一个致命点就是，一旦刷新的话，就会可能404，因为没有当前的真正路径，要想解决这一问题需要后端配合，将不存在的路径重定向到入口文件。")])])])]),v._v(" "),_("h2",{attrs:{id:"_9-mvc-与-mvvm-有什么区别-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-mvc-与-mvvm-有什么区别-中级"}},[v._v("#")]),v._v(" 9. MVC 与 MVVM 有什么区别（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("MVC")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Model(模型)是应用程序中用于处理应用程序"),_("strong",[v._v("数据逻辑的部分")]),v._v("。通常模型对象负责在数据库中"),_("strong",[v._v("存取数据")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("View(视图)是应用程序中处理"),_("strong",[v._v("数据显示的部分")]),v._v("。通常视图是依据模型数据创建的。")])]),v._v(" "),_("li",[_("p",[v._v("Controller(控制器)是应用程序中")]),v._v(" "),_("p",[v._v("处理用户交互的部分")]),v._v(" "),_("ul",[_("li",[v._v("通常控制器负责"),_("strong",[v._v("从视图读取数据，控制用户输入，并向模型发送数据")]),v._v("。")])])])])])]),v._v(" "),_("h2",{attrs:{id:"_10-diff-算法-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-diff-算法-中级"}},[v._v("#")]),v._v(" 10. diff 算法（中级）")]),v._v(" "),_("p",[v._v("diff 算法是指对新旧虚拟节点进行对比，并返回一个 patch 对象，用来存储两个节点不同的地方，最后利用 patch 记录的消息局部更新 DOM。")]),v._v(" "),_("h2",{attrs:{id:"_11-虚拟-dom-的优缺点-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-虚拟-dom-的优缺点-中级"}},[v._v("#")]),v._v(" 11. 虚拟 DOM 的优缺点（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[v._v("首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。")])])]),v._v(" "),_("li",[_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("减少了 DOM 操作，减少了回流与重绘。")])]),v._v(" "),_("li",[_("p",[v._v("保证性能的下限，虽说性能不是最佳，但是它具备局部更新的能力，所以大部分时候还是比正常的 DOM 性能高很多的。")])])])])]),v._v(" "),_("h2",{attrs:{id:"_12-vue-的-key-的作用-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue-的-key-的作用-中级"}},[v._v("#")]),v._v(" 12. Vue 的 Key 的作用（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("key")]),v._v(" "),_("ul",[_("li",[v._v("key 主要用在虚拟 Dom 算法中，每个虚拟节点 VNode 有一个唯一标识 Key，通过对比新旧节点的 key 来判断节点是否改变，用 key 就可以大大提高渲染效率，这个 key 类似于缓存中的 etag。")])])])]),v._v(" "),_("h2",{attrs:{id:"_13-vue-组件之间的通信方式-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-组件之间的通信方式-中级"}},[v._v("#")]),v._v(" 13. Vue 组件之间的通信方式（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("子组件设置props + 父组件设置"),_("code",[v._v("v-bind:")]),v._v("/"),_("code",[v._v(":")]),v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("父传子")])])]),v._v(" "),_("li",[_("p",[v._v("子组件的$emit + 父组件设置"),_("code",[v._v("v-on")]),v._v("/"),_("code",[v._v("@")]),v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("子传父")])])]),v._v(" "),_("li",[_("p",[v._v("任意组件通信，新建一个空的全局Vue对象，利用 e m i t 发 送 ， emit发送， emit发送，on接收。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("传说中的$bus")])]),v._v(" "),_("li",[_("p",[v._v("任意组件")]),v._v(" "),_("div",{staticClass:"language-javascript extra-class"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Vue")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("prototype"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("Event"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Vue")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n\t\nEvent"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("$emit")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("事件名"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("数据"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\nEvent"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("$on")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("事件名"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),_("span",{pre:!0,attrs:{class:"token parameter"}},[v._v("data")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=>")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])])])])]),v._v(" "),_("li",[_("p",[v._v("Vuex")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("里面的属性有：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("state")]),v._v(" "),_("ul",[_("li",[v._v("存储数据的。")]),v._v(" "),_("li",[v._v("获取数据最好推荐使用 getters。")]),v._v(" "),_("li",[v._v("硬要使用的话可以用 MapState， 先引用，放在 compute 中"),_("code",[v._v("...mapState(['方法名','方法名'])")]),v._v("。")])])]),v._v(" "),_("li",[_("p",[v._v("getters")]),v._v(" "),_("ul",[_("li",[v._v("获取数据的。")]),v._v(" "),_("li",[v._v("this.$store.getters.xxx。")]),v._v(" "),_("li",[v._v("也可使用mapGetters 先引用，放在compute中，"),_("code",[v._v("...mapGetters(['方法名','方法名'])")]),v._v("。")])])]),v._v(" "),_("li",[_("p",[v._v("mutations")]),v._v(" "),_("ul",[_("li",[v._v("同步操作数据的。")]),v._v(" "),_("li",[v._v("this.$store.commit(“方法名”,数据)。")]),v._v(" "),_("li",[v._v("也可使用mapMutations ，使用方法和以上一样。")])])]),v._v(" "),_("li",[_("p",[v._v("actions")]),v._v(" "),_("ul",[_("li",[v._v("异步操作数据的。")]),v._v(" "),_("li",[v._v("this.$store.dispatch(“方法名”,数据)。")]),v._v(" "),_("li",[v._v("也可使用mapActions ，使用方法和以上一样。")])])]),v._v(" "),_("li",[_("p",[v._v("modules")]),v._v(" "),_("ul",[_("li",[v._v("板块，里面可以放多个vuex。")])])])])])])]),v._v(" "),_("li",[_("p",[v._v("父组件通过"),_("code",[v._v("v-bind:")]),v._v("/"),_("code",[v._v(":")]),v._v("传值，子组件通过"),_("code",[v._v("this.$attrs")]),v._v("获取。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("父传子")])]),v._v(" "),_("li",[_("p",[v._v("当子组件没有设置props的时候可以使用")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("this.$attrs")]),v._v("获取到的是一个对象(所有父组件传过来的集合)")])])])]),v._v(" "),_("li",[_("p",[v._v("祖先组件使用provide提供数据，子孙组件通过inject注入数据。")])]),v._v(" "),_("li",[_("p",[v._v("p a r e n t / parent/ parent/children。")])]),v._v(" "),_("li",[_("p",[v._v("refs—$ref。")])]),v._v(" "),_("li",[_("p",[v._v("还有一个，这个网上没有，我自己认为的，我觉得挺对的，slot-scope，本身父组件使用slot插槽是无法获取子组件的数据的，但是使用了 slot-scope 就可以获取到子组件的数据(拥有了子组件的作用域)。")])])]),v._v(" "),_("h2",{attrs:{id:"_14-vue-router有哪几种钩子函数-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-router有哪几种钩子函数-中级"}},[v._v("#")]),v._v(" 14. Vue router有哪几种钩子函数？（中级）")]),v._v(" "),_("ul",[_("li",[v._v("beforeEach\n"),_("ul",[_("li",[v._v("参数有：\n"),_("ul",[_("li",[v._v("to(Route路由对象)")]),v._v(" "),_("li",[v._v("from(Route路由对象)")]),v._v(" "),_("li",[v._v("next(function函数) 一定要调用才能进行下一步")])])])])]),v._v(" "),_("li",[v._v("afterEach")]),v._v(" "),_("li",[v._v("beforeRouterLeave")])])])}),[],!1,null,null,null);e.default=a.exports}}]);