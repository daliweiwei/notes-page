<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>扩展阅读 | 大前端 - 前端高级进阶</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="大前端课程电子书">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/notes-page/assets/css/0.styles.116b8118.css" as="style"><link rel="preload" href="/notes-page/assets/js/app.ea65c3d0.js" as="script"><link rel="preload" href="/notes-page/assets/js/6.54d0d930.js" as="script"><link rel="preload" href="/notes-page/assets/js/74.07433cb3.js" as="script"><link rel="prefetch" href="/notes-page/assets/js/1.7013a9fc.js"><link rel="prefetch" href="/notes-page/assets/js/10.1a059821.js"><link rel="prefetch" href="/notes-page/assets/js/100.d07bd692.js"><link rel="prefetch" href="/notes-page/assets/js/101.23e1607e.js"><link rel="prefetch" href="/notes-page/assets/js/102.880e53b3.js"><link rel="prefetch" href="/notes-page/assets/js/103.981ad9d2.js"><link rel="prefetch" href="/notes-page/assets/js/104.d7cdf830.js"><link rel="prefetch" href="/notes-page/assets/js/105.ee9a5b2a.js"><link rel="prefetch" href="/notes-page/assets/js/11.87670d98.js"><link rel="prefetch" href="/notes-page/assets/js/12.d299e907.js"><link rel="prefetch" href="/notes-page/assets/js/13.0f438c9d.js"><link rel="prefetch" href="/notes-page/assets/js/14.71caaf05.js"><link rel="prefetch" href="/notes-page/assets/js/15.2552b947.js"><link rel="prefetch" href="/notes-page/assets/js/16.6b397fc0.js"><link rel="prefetch" href="/notes-page/assets/js/17.6f966caf.js"><link rel="prefetch" href="/notes-page/assets/js/18.f5640508.js"><link rel="prefetch" href="/notes-page/assets/js/19.eeaf3c0f.js"><link rel="prefetch" href="/notes-page/assets/js/20.25406e85.js"><link rel="prefetch" href="/notes-page/assets/js/21.dd1beb59.js"><link rel="prefetch" href="/notes-page/assets/js/22.3719f558.js"><link rel="prefetch" href="/notes-page/assets/js/23.633dbb77.js"><link rel="prefetch" href="/notes-page/assets/js/24.d6db78dd.js"><link rel="prefetch" href="/notes-page/assets/js/25.63630551.js"><link rel="prefetch" href="/notes-page/assets/js/26.d0076884.js"><link rel="prefetch" href="/notes-page/assets/js/27.0e652db9.js"><link rel="prefetch" href="/notes-page/assets/js/28.4a3a5dc4.js"><link rel="prefetch" href="/notes-page/assets/js/29.b0c51556.js"><link rel="prefetch" href="/notes-page/assets/js/30.d4f3ddff.js"><link rel="prefetch" href="/notes-page/assets/js/31.a70b692b.js"><link rel="prefetch" href="/notes-page/assets/js/32.b9b26fdd.js"><link rel="prefetch" href="/notes-page/assets/js/33.777c506b.js"><link rel="prefetch" href="/notes-page/assets/js/34.6cd1904d.js"><link rel="prefetch" href="/notes-page/assets/js/35.5600c55c.js"><link rel="prefetch" href="/notes-page/assets/js/36.5a3853cf.js"><link rel="prefetch" href="/notes-page/assets/js/37.091bb4ab.js"><link rel="prefetch" href="/notes-page/assets/js/38.a2b78387.js"><link rel="prefetch" href="/notes-page/assets/js/39.072932c1.js"><link rel="prefetch" href="/notes-page/assets/js/40.7ce1d545.js"><link rel="prefetch" href="/notes-page/assets/js/41.e8f97fc4.js"><link rel="prefetch" href="/notes-page/assets/js/42.5c88be8f.js"><link rel="prefetch" href="/notes-page/assets/js/43.09adba73.js"><link rel="prefetch" href="/notes-page/assets/js/44.a0688130.js"><link rel="prefetch" href="/notes-page/assets/js/45.20bd0a61.js"><link rel="prefetch" href="/notes-page/assets/js/46.fbfee310.js"><link rel="prefetch" href="/notes-page/assets/js/47.868c29ed.js"><link rel="prefetch" href="/notes-page/assets/js/48.e8c9c34d.js"><link rel="prefetch" href="/notes-page/assets/js/49.3012738d.js"><link rel="prefetch" href="/notes-page/assets/js/5.42ce73b7.js"><link rel="prefetch" href="/notes-page/assets/js/50.0b22a484.js"><link rel="prefetch" href="/notes-page/assets/js/51.96a83ae4.js"><link rel="prefetch" href="/notes-page/assets/js/52.ce9d7418.js"><link rel="prefetch" href="/notes-page/assets/js/53.2be0d783.js"><link rel="prefetch" href="/notes-page/assets/js/54.89a8516f.js"><link rel="prefetch" href="/notes-page/assets/js/55.9a1e4d50.js"><link rel="prefetch" href="/notes-page/assets/js/56.e0463cbb.js"><link rel="prefetch" href="/notes-page/assets/js/57.2364f241.js"><link rel="prefetch" href="/notes-page/assets/js/58.0d08a51e.js"><link rel="prefetch" href="/notes-page/assets/js/59.a4f37317.js"><link rel="prefetch" href="/notes-page/assets/js/60.61b9e19e.js"><link rel="prefetch" href="/notes-page/assets/js/61.3e5ce6da.js"><link rel="prefetch" href="/notes-page/assets/js/62.7c694d31.js"><link rel="prefetch" href="/notes-page/assets/js/63.d548df96.js"><link rel="prefetch" href="/notes-page/assets/js/64.943f1782.js"><link rel="prefetch" href="/notes-page/assets/js/65.62b64ff1.js"><link rel="prefetch" href="/notes-page/assets/js/66.857292a6.js"><link rel="prefetch" href="/notes-page/assets/js/67.0a9092ca.js"><link rel="prefetch" href="/notes-page/assets/js/68.c59a58d5.js"><link rel="prefetch" href="/notes-page/assets/js/69.68a53f34.js"><link rel="prefetch" href="/notes-page/assets/js/7.7e60c880.js"><link rel="prefetch" href="/notes-page/assets/js/70.1619ae86.js"><link rel="prefetch" href="/notes-page/assets/js/71.9421c754.js"><link rel="prefetch" href="/notes-page/assets/js/72.388e2316.js"><link rel="prefetch" href="/notes-page/assets/js/73.811f0259.js"><link rel="prefetch" href="/notes-page/assets/js/75.65a9ca8a.js"><link rel="prefetch" href="/notes-page/assets/js/76.219a63a5.js"><link rel="prefetch" href="/notes-page/assets/js/77.965fa8bb.js"><link rel="prefetch" href="/notes-page/assets/js/78.85479409.js"><link rel="prefetch" href="/notes-page/assets/js/79.edc855cb.js"><link rel="prefetch" href="/notes-page/assets/js/8.49fd3b63.js"><link rel="prefetch" href="/notes-page/assets/js/80.b246f0c5.js"><link rel="prefetch" href="/notes-page/assets/js/81.c630bd03.js"><link rel="prefetch" href="/notes-page/assets/js/82.de9022ae.js"><link rel="prefetch" href="/notes-page/assets/js/83.ebef715a.js"><link rel="prefetch" href="/notes-page/assets/js/84.af301120.js"><link rel="prefetch" href="/notes-page/assets/js/85.5102d72c.js"><link rel="prefetch" href="/notes-page/assets/js/86.6e4c8750.js"><link rel="prefetch" href="/notes-page/assets/js/87.7f2dcbfd.js"><link rel="prefetch" href="/notes-page/assets/js/88.6cc377e9.js"><link rel="prefetch" href="/notes-page/assets/js/89.8242738a.js"><link rel="prefetch" href="/notes-page/assets/js/9.e08b399d.js"><link rel="prefetch" href="/notes-page/assets/js/90.3b35fe2b.js"><link rel="prefetch" href="/notes-page/assets/js/91.1b5a25af.js"><link rel="prefetch" href="/notes-page/assets/js/92.f2449df1.js"><link rel="prefetch" href="/notes-page/assets/js/93.7fe9075a.js"><link rel="prefetch" href="/notes-page/assets/js/94.1ae61c96.js"><link rel="prefetch" href="/notes-page/assets/js/95.b9803d20.js"><link rel="prefetch" href="/notes-page/assets/js/96.2f0c2fc0.js"><link rel="prefetch" href="/notes-page/assets/js/97.9cfde8d6.js"><link rel="prefetch" href="/notes-page/assets/js/98.7a1eea3b.js"><link rel="prefetch" href="/notes-page/assets/js/99.15932a02.js"><link rel="prefetch" href="/notes-page/assets/js/vendors~docsearch.fd505987.js"><link rel="prefetch" href="/notes-page/assets/js/vendors~search-page.23629802.js">
    <link rel="stylesheet" href="/notes-page/assets/css/0.styles.116b8118.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes-page/" class="home-link router-link-active"><!----> <span class="site-name">大前端 - 前端高级进阶</span></a> <div class="links"><div id="docsearch"></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node.js进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes-page/basic/node/" class="sidebar-link">内容介绍</a></li><li><a href="/notes-page/basic/node/01-koa.html" class="sidebar-link">Koa(下一代web框架)</a></li><li><a href="/notes-page/basic/node/02-webpack5构建.html" class="sidebar-link">webpack5构建加持</a></li><li><a href="/notes-page/basic/node/03-项目规范及工具.html" class="sidebar-link">项目规范及工具</a></li><li><a href="/notes-page/basic/node/04-正则表达式入门.html" class="sidebar-link">正则表达式入门</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes-page/basic/ts/" aria-current="page" class="sidebar-link">导学</a></li><li><a href="/notes-page/basic/ts/01-学习方法.html" class="sidebar-link">学习方法</a></li><li><a href="/notes-page/basic/ts/02-环境配置.html" class="sidebar-link">环境配置</a></li><li><a href="/notes-page/basic/ts/03-基础类型.html" class="sidebar-link">基础类型</a></li><li><a href="/notes-page/basic/ts/03.1-函数类型.html" class="sidebar-link">函数类型</a></li><li><a href="/notes-page/basic/ts/04-新引入类型.html" class="sidebar-link">TS引入的新类型</a></li><li><a href="/notes-page/basic/ts/05-交叉类型与联合类型.html" class="sidebar-link">交叉类型与联合类型</a></li><li><a href="/notes-page/basic/ts/06-TS工作原理及概念.html" class="sidebar-link">工作原理相关概念</a></li><li><a href="/notes-page/basic/ts/07-接口Interface.html" class="sidebar-link">Interface 接口</a></li><li><a href="/notes-page/basic/ts/08-类.html" class="sidebar-link">Class 类</a></li><li><a href="/notes-page/basic/ts/09-泛型.html" class="sidebar-link">Generics 泛型</a></li><li><a href="/notes-page/basic/ts/10-类型别名与字面量.html" class="sidebar-link">类型别名type与字面量类型</a></li><li><a href="/notes-page/basic/ts/11-装饰器.html" class="sidebar-link">装饰器</a></li><li><a href="/notes-page/basic/ts/12-模块&amp;命名空间.html" class="sidebar-link">模块&amp;命名空间</a></li><li><a href="/notes-page/basic/ts/13-声明相关.html" class="sidebar-link">声明相关</a></li><li><a href="/notes-page/basic/ts/14-tsconfig.json配置文件.html" class="sidebar-link">tsconfig.json文件</a></li><li><a href="/notes-page/basic/ts/15-扩展阅读.html" class="active sidebar-link">扩展阅读</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#索引类型" class="sidebar-link">索引类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#索引类型查询操作符" class="sidebar-link">索引类型查询操作符</a></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#索引访问操作符" class="sidebar-link">索引访问操作符</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#映射类型" class="sidebar-link">映射类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#由映射类型进行推断" class="sidebar-link">由映射类型进行推断</a></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#增加或移除特定修饰符" class="sidebar-link">增加或移除特定修饰符</a></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#keyof-和映射类型在-2-9-的升级" class="sidebar-link">keyof 和映射类型在 2.9 的升级</a></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#元组和数组上的映射类型" class="sidebar-link">元组和数组上的映射类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#条件类型" class="sidebar-link">条件类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#基础使用" class="sidebar-link">基础使用</a></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#分布式条件类型" class="sidebar-link">分布式条件类型</a></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#条件类型的类型推断" class="sidebar-link">条件类型的类型推断</a></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#预定义条件类型" class="sidebar-link">预定义条件类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#混入" class="sidebar-link">混入</a></li><li class="sidebar-sub-header"><a href="/notes-page/basic/ts/15-扩展阅读.html#promise及async-await" class="sidebar-link">Promise及async/await</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>mongoDB</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes-page/basic/mongo/" class="sidebar-link">认识 MongoDB</a></li><li><a href="/notes-page/basic/mongo/01-创建用户并分配权限.html" class="sidebar-link">创建用户并分配权限</a></li><li><a href="/notes-page/basic/mongo/01.1连接MongoDB.html" class="sidebar-link">MongoDB交互终端</a></li><li><a href="/notes-page/basic/mongo/02-基础操作.html" class="sidebar-link">基本操作</a></li><li><a href="/notes-page/basic/mongo/03-高级查询.html" class="sidebar-link">高级查询</a></li><li><a href="/notes-page/basic/mongo/04-复制集.html" class="sidebar-link">复制集</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="扩展阅读"><a href="#扩展阅读" class="header-anchor">#</a> 扩展阅读</h1> <p>这部分有很多内容都是变化中，作为扩展学习时食用。</p> <h2 id="索引类型"><a href="#索引类型" class="header-anchor">#</a> 索引类型</h2> <p>这里要讲的，可不是前面讲接口的时候讲的索引类型。在学习接口内容的时候，讲过可以指定索引的类型。而本小节讲的索引类型包含两个内容：<strong>索引类型查询</strong>和<strong>索引访问</strong>操作符。</p> <h3 id="索引类型查询操作符"><a href="#索引类型查询操作符" class="header-anchor">#</a> 索引类型查询操作符</h3> <p><code>keyof</code>操作符，连接一个类型，会返回一个由这个类型的所有属性名组成的联合类型。来看例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> infoProp<span class="token operator">:</span> <span class="token keyword">keyof</span> Info<span class="token punctuation">;</span>
infoProp <span class="token operator">=</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">;</span>
infoProp <span class="token operator">=</span> <span class="token string">&quot;age&quot;</span><span class="token punctuation">;</span>
infoProp <span class="token operator">=</span> <span class="token string">&quot;no&quot;</span><span class="token punctuation">;</span> <span class="token comment">// error 不能将类型“&quot;no&quot;”分配给类型“&quot;name&quot; | &quot;age&quot;”</span>
</code></pre></div><p>通过例子可以看到，这里的<code>keyof Info</code>其实相当于<code>&quot;name&quot; | “age”</code>。</p> <p>通过和泛型结合使用，TS 就可以检查使用了动态属性名的代码：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 这里使用泛型，并且约束泛型变量K的类型是&quot;keyof T&quot;，也就是类型T的所有字段名组成的联合类型</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getValue</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> names<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> 
  <span class="token comment">// 指定getValue的返回值类型为T[K][]，即类型为T的值的属性值组成的数组</span>
  <span class="token keyword">return</span> names<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> obj<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">const</span> info <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> values<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// error 不能将类型“number[]”分配给类型“string[]”</span>
values <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;age&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><h3 id="索引访问操作符"><a href="#索引访问操作符" class="header-anchor">#</a> 索引访问操作符</h3> <p>索引访问操作符也就是<code>[]</code>，其实和访问对象的某个属性值是一样的语法，但是在 TS 中它可以用来访问某个属性的类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">NameType</span> <span class="token operator">=</span> Info<span class="token punctuation">[</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> name<span class="token operator">:</span> NameType <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// error 不能将类型“123”分配给类型“string”</span>
</code></pre></div><p>再来看个例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getProperty</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> o<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// o[name] is of type T[K]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数中，两个参数的类型分别为泛型 T 和 K，而函数的返回值类型为<code>T[K]</code>，只要函数的返回值也是这种形式，即访问参数 o 的参数 name 属性，即可。</p> <p>最后来看个结合接口的例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Obj<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> key<span class="token operator">:</span> <span class="token keyword">keyof</span> Obj<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// keys的类型为number</span>
</code></pre></div><p>这里需要注意，如果索引类型为 number，那么实现该接口的对象的属性名必须是 number 类型；</p> <p>但是如果接口的索引类型是 string 类型，那么实现该接口的对象的属性名设置为数值类型的值也是可以的，因为数值最后还是会先转换为字符串。</p> <p>这里一样，如果接口的索引类型设置为 string 的话，<code>keyof Obj&lt;number&gt;</code>等同于类型<code>number | string</code>：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Obj<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> key<span class="token operator">:</span> <span class="token keyword">keyof</span> Obj<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// keys的类型为number | string</span>
key <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// right</span>
</code></pre></div><p>也可以使用访问操作符，获取索引签名的类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Obj<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj<span class="token operator">:</span> Obj<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> value<span class="token operator">:</span> Obj<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token string">&quot;age&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// value的类型是number，也就是name的属性值18的类型</span>
</code></pre></div><p>还有一点，在讲后面知识的时候会遇到，就是当tsconfig.json里<code>strictNullChecks</code>设为<code>false</code>时，通过<code>Type[keyof Type]</code>获取到的，是除去<code>never &amp; undefined &amp; null</code>这三个类型之后的字段值类型组成的联合类型，来看例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Type</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
  b<span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
  c<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  d<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  e<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  f<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  g<span class="token operator">:</span> object<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">test</span> <span class="token operator">=</span> Type<span class="token punctuation">[</span><span class="token keyword">keyof</span> Type<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// test的类型是string | number | object</span>
</code></pre></div><p>这个例子中接口 Type 有几个属性，通过索引访问操作符和索引类型查询操作符可以选出类型不为 never &amp; undefined &amp; null 的类型。</p> <h2 id="映射类型"><a href="#映射类型" class="header-anchor">#</a> 映射类型</h2> <p>TS 提供了借助旧类型创建一个新类型的方式，也就是映射类型，它可以用相同的形式去转换旧类型中每个属性。来看个例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以使用这个接口实现一个有且仅有一个 age 属性的对象，但如果想再创建一个只读版本的同款对象，那可能需要再重新定义一个接口，然后让 age 属性 readonly。</p> <p>如果接口就这么简单，确实可以这么做，但是如果属性多了，而且这个结构以后会变，那就比较麻烦了。</p> <p>这种情况可以使用映射类型，下面来看例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">ReadonlyType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 这里定义了一个ReadonlyType&lt;T&gt;映射类型</span>

<span class="token keyword">type</span> <span class="token class-name">ReadonlyInfo</span> <span class="token operator">=</span> ReadonlyType<span class="token operator">&lt;</span>Info<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> info<span class="token operator">:</span> ReadonlyInfo <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

info<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span> <span class="token comment">// error Cannot assign to 'age' because it is a constant or a read-only property</span>
</code></pre></div><p>这个例子展示了如何通过一个普通的接口创建一个每个属性都只读的接口，这个过程有点像定义了一个函数，这个函数会遍历传入对象的每个属性并做处理。</p> <p>注意了，在这里用到了一个新的操作符 in，TS 内部使用了 for … in，定义映射类型，这里涉及到三个部分：</p> <ul><li>类型变量，也就是上例中的 P，它就像 for…in 循环中定义的变量，用来在每次遍历中绑定当前遍历到的属性名；</li> <li>属性名联合，也就是上例中<code>keyof T</code>，它返回对象 T 的属性名联合；</li> <li>属性的结果类型，也就是 T[P]。</li></ul> <p>因为这两个需求较为常用，所以 TS 内置了这两种映射类型，无需定义即可使用，它们分别是<code>Readonly</code>和<code>Partial</code>。</p> <p>还有两个内置的映射类型分别是<code>Pick</code>和<code>Record</code>，它们的实现如下：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>先来使用一下 Pick，官方文档的例子并不完整，来看完整的例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  address<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> info<span class="token operator">:</span> Info <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
  address<span class="token operator">:</span> <span class="token string">&quot;beijing&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">pick</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> keys<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 这里定义一个pick函数，用来返回一个对象中指定字段的值组成的对象</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  keys<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> nameAndAddress <span class="token operator">=</span> <span class="token function">pick</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;address&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { name: 'toimc', address: 'beijing' }</span>
</code></pre></div><p>另外一个就是 Record，它适用于将一个对象中的每一个属性转换为其他值的场景，来看例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">mapObject</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
  obj<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">U</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Record<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> names <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token string">&quot;bye&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> lengths <span class="token operator">=</span> <span class="token function">mapObject</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> s <span class="token operator">=&gt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { 0: 5, 1: 5, 2: 3 }</span>
</code></pre></div><p>输入的对象属性值为字符串类型，输出的对象属性值为数值类型。</p> <p>这四个内置映射类型中，Readonly、Partial 和 Pick 是同态的，而 Record 不是，因为 Record 映射出的对象属性值是新的，和输入的值的属性值不同。</p> <blockquote><p>同态：两个相同类型的代数结构之间的结构保持映射</p></blockquote> <h3 id="由映射类型进行推断"><a href="#由映射类型进行推断" class="header-anchor">#</a> 由映射类型进行推断</h3> <p>学习了使用映射类型包装一个类型的属性后，也可以进行逆向操作，也就是拆包，先来看的包装操作：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Proxy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">// 这里定义一个映射类型，他将一个属性拆分成get/set方法</span>
  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> Proxy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 这里再定义一个映射类型，将一个对象的所有属性值类型都变为Proxy&lt;T&gt;处理之后的类型</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">proxify</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 这里定义一个proxify函数，用来将对象中所有属性的属性值改为一个包含get和set方法的对象</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token function-variable function">set</span><span class="token operator">:</span> value <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> proxyProps <span class="token operator">=</span> <span class="token function">proxify</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyProps<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;toimc&quot;</span>
proxyProps<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>来看下这个例子，这个例子定义了一个函数，这个函数可以把传入的对象的每个属性的值替换为一个包含 get 和 set 两个方法的对象。最后获取某个值的时候，比如 name，就使用 proxyProps.name.get()方法获取它的值，使用 proxyProps.name.set()方法修改 name 的值。</p> <p>接下来来看如何进行拆包：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">unproxify</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token operator">:</span> Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span> <span class="token comment">// 这里定义一个拆包函数，其实就是利用每个属性的get方法获取到当前属性值，然后将原本是包含get和set方法的对象改为这个属性值</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里通过调用属性值这个对象的get方法获取到属性值，然后赋给这个属性，替换掉这个对象</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> originalProps <span class="token operator">=</span> <span class="token function">unproxify</span><span class="token punctuation">(</span>proxyProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="增加或移除特定修饰符"><a href="#增加或移除特定修饰符" class="header-anchor">#</a> 增加或移除特定修饰符</h3> <p>TS 在 2.8 版本为映射类型增加了增加或移除特定修饰符的能力，使用<code>+</code>和<code>-</code>符号作为前缀来指定增加还是删除修饰符。</p> <p>首先来看如何通过映射类型为一个接口的每个属性增加修饰符，这里使用+前缀：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 通过+前缀增加了 readonly 和?修饰符, 当然，增加的时候，这个+前缀可以省略</span>
<span class="token comment">// 等价 type ReadonlyInfo = { readonly [P in keyof T]?: T[P] }</span>
<span class="token keyword">type</span> <span class="token class-name">ReadonlyInfo<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">+</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> info<span class="token operator">:</span> ReadonlyInfo<span class="token operator">&lt;</span>Info<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
info<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
</code></pre></div><p>这个例子中，经过 ReadonlyInfo 创建的接口类型，属性是可选的，所以在定义 info 的时候没有写 age 属性也没问题。</p> <p>同时每个属性是只读的，所以修改 name 的值的时候报错。</p> <p>再来看下怎么删除修饰符：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">RemoveModifier<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">InfoType</span> <span class="token operator">=</span> RemoveModifier<span class="token operator">&lt;</span>Readonly<span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>Info<span class="token operator">&gt;&gt;&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> info1<span class="token operator">:</span> InfoType <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// error missing &quot;age&quot;</span>
  name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> info2<span class="token operator">:</span> InfoType <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
info2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">// right, can edit</span>
</code></pre></div><p>这个例子定义了去掉修饰符的映射类型 RemoveModifier，<code>Readonly&lt;Partial&lt;Info&gt;&gt;</code>则是返回一个既属性可选又只读的接口类型，所以 InfoType 类型则表示属性必含而且非只读。</p> <p>TS 内置了一个映射类型<code>Required&lt;T&gt;</code>，使用它可以去掉 T 所有属性的<code>?</code>修饰符。</p> <h3 id="keyof-和映射类型在-2-9-的升级"><a href="#keyof-和映射类型在-2-9-的升级" class="header-anchor">#</a> keyof 和映射类型在 2.9 的升级</h3> <p>TS 在 2.9 版本中，keyof 和映射类型支持用 number 和 symbol 命名的属性，先来看 keyof 的例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> stringIndex <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> numberIndex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> symbolIndex <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Obj</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>stringIndex<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>numberIndex<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>symbolIndex<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">symbol</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">keys</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Obj<span class="token punctuation">;</span>
<span class="token keyword">let</span> key<span class="token operator">:</span> keys <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token keyword">let</span> key<span class="token operator">:</span> keys <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// right</span>
<span class="token keyword">let</span> key<span class="token operator">:</span> keys <span class="token operator">=</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token keyword">let</span> key<span class="token operator">:</span> keys <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span> <span class="token comment">// right</span>
<span class="token keyword">let</span> key<span class="token operator">:</span> keys <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token keyword">let</span> key<span class="token operator">:</span> keys <span class="token operator">=</span> symbolIndex<span class="token punctuation">;</span> <span class="token comment">// right</span>
</code></pre></div><p>再来看个映射类型的例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> stringIndex <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> numberIndex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> symbolIndex <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Obj</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>stringIndex<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>numberIndex<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>symbolIndex<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">symbol</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">ReadonlyType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj<span class="token operator">:</span> ReadonlyType<span class="token operator">&lt;</span>Obj<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token string">&quot;aa&quot;</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>symbolIndex<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">&quot;bb&quot;</span><span class="token punctuation">;</span> <span class="token comment">// error Cannot assign to 'a' because it is a read-only property</span>
obj<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">// error Cannot assign to '1' because it is a read-only property</span>
obj<span class="token punctuation">[</span>symbolIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error Cannot assign to '[symbolIndex]' because it is a read-only property</span>
</code></pre></div><h3 id="元组和数组上的映射类型"><a href="#元组和数组上的映射类型" class="header-anchor">#</a> 元组和数组上的映射类型</h3> <p>TS 在 3.1 版本中，在元组和数组上的映射类型会生成新的元组和数组，并不会创建一个新的类型，这个类型上会具有 push、pop 等数组方法和数组属性。来看例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">MapToPromise<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Tuple</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">promiseTuple</span> <span class="token operator">=</span> MapToPromise<span class="token operator">&lt;</span>Tuple<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> tuple<span class="token operator">:</span> promiseTuple <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>这个例子中定义了一个MapToPromise映射类型。</p> <p>它返回一个将传入的类型的所有字段的值转为Promise，且Promise的resolve回调函数的参数类型为这个字段类型。</p> <p>定义了一个元组Tuple，元素类型分别为number、string和boolean，使用MapToPromise映射类型将这个元组类型传入，并且返回一个promiseTuple类型。</p> <p>当指定变量tuple的类型为promiseTuple后，它的三个元素类型都是一个Promise，且resolve的参数类型依次为number、string和boolean。</p> <h2 id="条件类型"><a href="#条件类型" class="header-anchor">#</a> 条件类型</h2> <h3 id="基础使用"><a href="#基础使用" class="header-anchor">#</a> 基础使用</h3> <p>条件类型是 TS2.8 引入的，从语法上看它像是三元操作符。它会以一个条件表达式进行类型关系检测，然后在后面两种类型中选择一个，先来看它怎么写：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">X</span> <span class="token operator">:</span> <span class="token constant">Y</span>
</code></pre></div><p>这个表达式的意思是，如果 T 可以赋值给 U 类型，则是 X 类型，否则是 Y 类型。来看个实际例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Type<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">|</span> <span class="token builtin">number</span>
<span class="token keyword">let</span> index<span class="token operator">:</span> Type<span class="token operator">&lt;</span><span class="token string">'a'</span><span class="token operator">&gt;</span> <span class="token comment">// index的类型为string</span>
<span class="token keyword">let</span> index2<span class="token operator">:</span> Type<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token operator">&gt;</span> <span class="token comment">// index2的类型为number</span>
</code></pre></div><h3 id="分布式条件类型"><a href="#分布式条件类型" class="header-anchor">#</a> 分布式条件类型</h3> <p>当待检测的类型是联合类型，则该条件类型被称为“分布式条件类型”，在实例化时会自动分发成联合类型，来看例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">TypeName<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Type1的类型是string|number</span>
</code></pre></div><p>可能会说，既然想指定 Type1 的类型为 string|number，为什么不直接指定，而要使用条件类型？</p> <p>其实这只是简单的示范，条件类型可以增加灵活性，再来看个复杂点的例子，这是官方文档的例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">TypeName<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>
  <span class="token operator">?</span> <span class="token builtin">string</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span>
  <span class="token operator">?</span> <span class="token builtin">number</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span>
  <span class="token operator">?</span> <span class="token builtin">boolean</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">undefined</span></span>
  <span class="token operator">?</span> <span class="token keyword">undefined</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Function</span></span>
  <span class="token operator">?</span> <span class="token builtin">Function</span>
  <span class="token operator">:</span> object<span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Type1的类型是Function</span>
<span class="token keyword">type</span> <span class="token class-name">Type2</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Type2的类型是object</span>
<span class="token keyword">type</span> <span class="token class-name">Type3</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Type3的类型是object | Function</span>
</code></pre></div><p>来看一个分布式条件类型的实际应用：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Diff<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Test</span> <span class="token operator">=</span> Diff<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// Test的类型为string | boolean</span>
</code></pre></div><p>这个例子定义的条件类型的作用就是，找出从 T 中出去 U 中存在的类型，得到剩下的类型。不过这个条件类型已经内置在 TS 中了，只不过它不叫 Diff，叫 Exclude，待会儿会讲到。</p> <p>来看一个条件类型和映射类型结合的例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Type<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Function</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">interface</span> <span class="token class-name">Part</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  subparts<span class="token operator">:</span> Part<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">updatePart</span><span class="token punctuation">(</span>newName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Test</span> <span class="token operator">=</span> Type<span class="token operator">&lt;</span>Part<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Test的类型为&quot;updatePart&quot;</span>
</code></pre></div><p>来看一下，这个例子中，接口 Part 有四个字段，其中 updatePart 的值是函数，也就是 Function 类型。</p> <p>Type的定义中，涉及到映射类型、条件类型、索引访问类型和索引类型。</p> <p>首先[K in keyof T]用于遍历 T 的所有属性名，值使用了条件类型，T[K]是当前属性名的属性值，<code>T[K] extends Function ? K : never</code>表示如果属性值为 Function 类型，则值为属性名字面量类型，否则为 never 类型。</p> <p>接下来使用<code>keyof T</code>获取 T 的属性名，最后通过索引访问类型<code>[keyof T]</code>获取不为 never 的类型。</p> <h3 id="条件类型的类型推断"><a href="#条件类型的类型推断" class="header-anchor">#</a> 条件类型的类型推断</h3> <p>条件类型提供一个<code>infer</code>关键字用来推断类型，先来看个例子。</p> <p>想定义一个条件类型，如果传入的类型是一个数组，则返回它元素的类型；如果是一个普通类型，则直接返回这个类型。来</p> <p>看下不使用 infer 的话，怎么写：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Type<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">test</span> <span class="token operator">=</span> Type<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// test的类型为string</span>
<span class="token keyword">type</span> <span class="token class-name">test2</span> <span class="token operator">=</span> Type<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// test2的类型为string</span>
</code></pre></div><p>这个例子中，如果传入 Type 的是一个数组类型，那么返回的类型为<code>T[number]</code>，也就是该数组的元素类型。如果不是数组，则直接返回这个类型。</p> <p>这里是自己通过索引访问类型<code>T[number]</code>来获取类型的，如果使用 infer 关键字则无需自己手动获取，来看下怎么使用 infer：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Type<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span>infer <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">test</span> <span class="token operator">=</span> Type<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// test的类型为string</span>
<span class="token keyword">type</span> <span class="token class-name">test2</span> <span class="token operator">=</span> Type<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// test2的类型为string</span>
</code></pre></div><p>这里 infer 能够推断出 U 的类型，并且供后面使用，可以理解为这里定义了一个变量 U 来接收数组元素的类型。</p> <h3 id="预定义条件类型"><a href="#预定义条件类型" class="header-anchor">#</a> 预定义条件类型</h3> <p>TS 在 2.8 版本增加了一些预定义的有条件类型，来看一下：</p> <ul><li>Exclude&lt;T, U&gt;，从 T 中去掉可以赋值给 U 的类型：</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Type</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// Type =&gt; 'c'</span>
<span class="token keyword">type</span> <span class="token class-name">Type2</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// Type2 =&gt; boolean</span>
</code></pre></div><ul><li>Extract&lt;T, U&gt;，选取 T 中可以赋值给 U 的类型：</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Type</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// Type =&gt; 'a' | 'c'</span>
<span class="token keyword">type</span> <span class="token class-name">Type2</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// Type2 =&gt; string | boolean</span>
</code></pre></div><ul><li>NonNullable，从 T 中去掉 null 和 undefined：</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Type</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// Type =&gt; string | number</span>
</code></pre></div><ul><li>ReturnType，获取函数类型返回值类型：</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Type</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token comment">// Type =&gt; string</span>
<span class="token keyword">type</span> <span class="token class-name">Type2</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token comment">// Type2 =&gt; void</span>
</code></pre></div><ul><li>InstanceType，获取构造函数类型的实例类型：</li></ul> <p>InstanceType直接看例子可能不好理解，所以先来看下它的实现：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">InstanceType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">new</span></span> <span class="token punctuation">(</span>
  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer <span class="token constant">R</span>
  <span class="token operator">?</span> <span class="token constant">R</span>
  <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><p>InstanceType 条件类型要求泛型变量 T 类型是创建实例为 any 类型的构造函数，而它本身则通过判断 T 是否是构造函数类型来确定返回的类型。如果是构造函数，使用 infer 可以自动推断出 R 的类型，即实例类型；否则返回的是 any 类型。</p> <p>看过 InstanceType 的实现后，来看怎么使用：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// T1的类型为A</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// T2的类型为any</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// T3的类型为never</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
</code></pre></div><p>上面例子中：</p> <p>T1 的定义中，<code>typeof A</code>返回的的是类 A 的类型，也就是 A，这里不能使用 A 因为它是值不是类型，类型 A 是构造函数，所以 T1 是 A 构造函数的实例类型，也就是 A；T2 传入的类型为 any，因为 any 是任何类型的子类型，所以它满足<code>T extends new (…args: any[]) =&gt; infer R</code>，这里 infer 推断的 R 为 any；传入 never 和 any 同理。传入 string 时因为 string 不能不给构造函数类型，所以报错。</p> <h2 id="混入"><a href="#混入" class="header-anchor">#</a> 混入</h2> <p>混入即把两个对象或者类的内容，混合起来，从而实现一些功能的复用。</p> <p>如果使用过 Vue，应该知道 Vue 的 mixins 这个 api，它可以允许将一些抽离到对象的属性、方法混入到一些组件。接下来先来看看个在 JavaScript 中实现的简单混入：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;here&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">funcB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">mixin</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 这里定义一个函数来将一个类混入到目标类</span>
  Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 通过Object.getOwnPropertyNames可以获取一个对象自身定义的而非继承来的属性名组成的数组</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 将源类原型对象上的属性拿来添加到目标类的原型对象上</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">mixin</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传入两个类的原型对象</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// here</span>
</code></pre></div><p>通过<code>Object.getOwnPropertyNames</code>方法获取一个对象自身的属性，这里自身指除去继承的属性，获取到属性后将属性赋值给目标对象。</p> <p>这是 JavaScript 中的简单混入，在 TypeScript 中知道，除了值还有类型的概念，所以简单地将属性赋值到目标元素是不行的，还要处理类型定义，来看下 TypeScript 中混入的例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">ClassAa</span> <span class="token punctuation">{</span>
  isA<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ClassBb</span> <span class="token punctuation">{</span>
  isB<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token function">funcB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 定义一个类类型接口AB，在讲类的时候补充过类和接口之间的继承，也讲过类类型接口</span>
<span class="token comment">// 这里是让类AB继承ClassAa和ClassBb的类型，所以使用implements关键字，而不是用extends</span>
<span class="token class-name"><span class="token keyword">class</span></span> <span class="token constant">AB</span> <span class="token keyword">implements</span> <span class="token class-name">ClassAa</span><span class="token punctuation">,</span> ClassBb <span class="token punctuation">{</span>        
  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  isA<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 定义两个实例属性</span>
  isB<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token function-variable function">funcA</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// 定义两个方法，并指定类型</span>
  <span class="token function-variable function">funcB</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mixins</span><span class="token punctuation">(</span>base<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这里改造一下，直接传入类，而非其原型对象，base是最后要汇总而成的类，from是个数组，是要混入的源类组成的数组</span>
  <span class="token keyword">from</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fromItem <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>fromItem<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      base<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> fromItem<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">mixins</span><span class="token punctuation">(</span><span class="token constant">AB</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ClassAa<span class="token punctuation">,</span> ClassBb<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> ab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">AB</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ab<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
{
    isA: false,
    isB: false,
    __proto__: {
        funcA: f ()
        funcB: f ()
        constructor: f
    }
}
*/</span>
</code></pre></div><p>这个例子中定义了两个类 A 和 B，它们分别有自己的方法和实力属性。</p> <p>如果想使用它们的所有属性和方法来创建实例，就需要将它们做一个混合。因为包含类型定义，所以首先要定义一个接口，来包含着两个类中元素类型的定义。</p> <p>定义一个类类型接口，然后让这个类类型接口 AB 通过 implements 继承 A 和 B 这两个类，这样类 AB 就会同时拥有类 A 和 B 的类型定义，还有自身定义的一些类型和值。</p> <p>所以此时类 AB 相当于：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">AB</span></span> <span class="token punctuation">{</span>
  isA<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  isB<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token function-variable function">funcA</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token function-variable function">funcB</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过 mixins 函数将类 A 和类 B 的原型对象的属性方法赋值给类 AB，因为类 AB 有 funcA 和 funcB 的类型定义，可以把 funcA 和 funcB 函数实体赋值给类 AB。</p> <h2 id="promise及async-await"><a href="#promise及async-await" class="header-anchor">#</a> Promise及async/await</h2> <p>与ES6+中</p> <p>TS 在 1.6 版本实验性地支持了 async 函数。</p> <p>在过去的 JavaScript 当中，如果想保证代码的执行顺序，需要使用回调函数，当需要执行的步骤多了时就会陷入当说的“回调地狱”。</p> <p>自从 ES6 增加了 Promise 之后，状况有了缓解，先来看个例子，一个简单的多个 ajax 请求的例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>ajax<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span> <span class="token comment">// 这里可以先忽略ajax的定义，他的post方法用来发送一个post请求</span>
  <span class="token string">&quot;/login&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 第一个参数时要请求的url</span>
  <span class="token punctuation">{</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      user_name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span><span class="token punctuation">,</span>
      password<span class="token operator">:</span> <span class="token string">&quot;xxxxx&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 第二个参数是这个请求要携带的参数</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> user_id <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>user_id<span class="token punctuation">;</span>
    ajax<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span> <span class="token comment">// 这里在/login接口成功返回数据后，再调用一个/user_roles接口，用来获取该登录用户的角色信息</span>
      <span class="token string">&quot;/user_roles&quot;</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
          user_id<span class="token operator">:</span> user_id
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> role <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>role<span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>role<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token comment">// 第三个参数是接口响应之后的回调函数</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这个例子中：</p> <ul><li>先调用登录的接口发送用户名和密码</li> <li>服务端进行校验之后返回这个用户的一些信息</li> <li>可以从信息中拿到用户 id 去获取它的角色用于权限控制。</li></ul> <p>这个过程是有先后顺序的，必须先登录后获取角色，为了保证这个顺序，在过去要使用回调函数，当然一些库也支持链式调用。</p> <p>再来看下使用 ES6 的 Promise 需要怎么写：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">loginReq</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> user_name<span class="token punctuation">,</span> password <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 封装一个loginReq函数，用来返回一个Promise，用来调用/login接口</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// Promise接收一个回调函数参数，这个函数有两个参数，两个参数都是回调函数</span>
    ajax<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>
      <span class="token string">&quot;/login&quot;</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        user_name<span class="token punctuation">,</span>
        password
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一个参数resolve用来在执行成功后调用，传给他的参数，可以在这个promise的then函数参数中获取到</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二个参数reject用来在执行出现错误后调用，传给他的错误信息，可以在这个promise的catch函数参数中获取到</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">getRolesReq</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> user_id <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 封装一个getRolesReq函数，用来返回一个Promise，用来调用/user_roles接口</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    ajax<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>
      <span class="token string">&quot;/user_roles&quot;</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
          user_id
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">loginReq</span><span class="token punctuation">(</span><span class="token punctuation">{</span> user_name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span><span class="token punctuation">,</span> password<span class="token operator">:</span> <span class="token string">&quot;xxxxx&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 这里在调用loginReq函数后返回一个Promise，在内部当执行到resolve的地方时，这里的then的回调函数就会执行</span>
  <span class="token function">getRolesReq</span><span class="token punctuation">(</span><span class="token punctuation">{</span> user_id<span class="token operator">:</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>user_id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>role<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这看起来代码变长了，但是当搭配使用诸如 Axios 这类 ajax 请求库和 ES6 语法时，对于一些复用性高的接口调用能够起到很好的封装作用，而且使用起来较为简洁。</p> <p>ES7 中增加了 async 和 await 的规范，它们其实是 Promise 的语法糖。</p> <p>TypeScript 在 1.6 支持了 async 和 await，下面通过 setTimeout 来实现异步过程，看下在 TypeScript 中如何使用 async 和 await：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Res</span> <span class="token punctuation">{</span> <span class="token comment">// 定义一个接口，用来定义接口返回结果的结构</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 首先定义一个命名空间 axios，定义它用来简单模拟 axios 这个 ajax 请求库。</span>
<span class="token keyword">namespace</span> axios <span class="token punctuation">{</span> <span class="token comment">// 现在来定义一个命名空间，用来模拟axios实现接口调用</span>
  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">post</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> config<span class="token operator">:</span> object<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Res<span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 返回值类型是一个Promise，resolve传的参数的类型是Res</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 然后这里返回一个Promise</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 通过setTimeout实现异步效果</span>
        <span class="token keyword">let</span> res<span class="token operator">:</span> Res <span class="token operator">=</span> <span class="token punctuation">{</span> data<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>url <span class="token operator">===</span> <span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>user_id <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span> <span class="token comment">// 这里通过简单判断，来模拟调用不同接口返回不同数据的效果</span>
        <span class="token keyword">else</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>role <span class="token operator">=</span> <span class="token string">&quot;admin&quot;</span><span class="token punctuation">;</span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这里传入res结果</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
  
<span class="token keyword">interface</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>
  user_name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  password<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
  
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">loginReq</span><span class="token punctuation">(</span><span class="token punctuation">{</span> user_name<span class="token punctuation">,</span> password <span class="token punctuation">}</span><span class="token operator">:</span> Info<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这里使用async关键字修饰这个函数，那么他内部就可以包含异步逻辑了</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">// 这里调用/login接口</span>
      data<span class="token operator">:</span> <span class="token punctuation">{</span>
        user_name<span class="token punctuation">,</span>
        password
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
  
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getRoleReq</span><span class="token punctuation">(</span>user_id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">&quot;/user_roles&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      data<span class="token operator">:</span> <span class="token punctuation">{</span>
        user_id
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
  
<span class="token function">loginReq</span><span class="token punctuation">(</span><span class="token punctuation">{</span> user_name<span class="token operator">:</span> <span class="token string">&quot;toimc&quot;</span><span class="token punctuation">,</span> password<span class="token operator">:</span> <span class="token string">&quot;123&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span> user_id <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>
  <span class="token function">getRoleReq</span><span class="token punctuation">(</span>user_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>
      data<span class="token operator">:</span> <span class="token punctuation">{</span> role <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>role<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div> <!----> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes-page/basic/ts/14-tsconfig.json配置文件.html" class="prev">
        tsconfig.json文件
      </a></span> <span class="next"><a href="/notes-page/basic/mongo/">
        认识 MongoDB
      </a>
      →
    </span></p></div>  <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="dialog" class="el-dialog" style="margin-top:15vh;width:420px;"><div class="el-dialog__header"><span class="el-dialog__title"></span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button type="button" class="el-button el-button--default"><!----><!----><span>取 消</span></button> <button type="button" class="el-button el-button--primary"><!----><!----><span>确 定</span></button></span></div></div></div></main> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/notes-page/assets/js/app.ea65c3d0.js" defer></script><script src="/notes-page/assets/js/6.54d0d930.js" defer></script><script src="/notes-page/assets/js/74.07433cb3.js" defer></script>
  </body>
</html>
